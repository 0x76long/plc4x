//
//  Licensed to the Apache Software Foundation (ASF) under one or more
//  contributor license agreements.  See the NOTICE file distributed with
//  this work for additional information regarding copyright ownership.
//  The ASF licenses this file to You under the Apache License, Version 2.0
//  (the "License"); you may not use this file except in compliance with
//  the License.  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
:imagesdir: img/
:icons: font

== Conventions

All formats used for defining protocols are very feature-rich.
This would cause the code generator to be extremely complex.

In order to keep things as simple as possible the plugin makes some assumptions.
These are documented in this document.

== DFDL

* Namespaces:
** All namespaces must be defined on the root element. If a namespace is defined on any other element, the generator will not find it.
** Each document must defined the `xs` and the `dfdl` namespace prefixes
** Each document must declare the protocol namespace and define which one it is in with the `targetNamespace` attribute.

* Root of all messages:
** Each DFDL schema must only define one `xs:element` on root level. This will be the root of all message types.
** The root element must define a `name` as well as a `type` attribute (No embedded type definition).

* Simple types:
** All simple types must be declared at the top.
** No simple types are allowed to be declared inline

* Complex types:
** A complex type can only reference simple types declared at the top or other complex types declared after the current type.

2. For each `xs:complexType` on root level the code generator will generate a type.
3. Nested `xs:complexType`s will be generated as nested types.
4. For all types, that
